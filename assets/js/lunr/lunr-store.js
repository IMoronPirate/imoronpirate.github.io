var store = [{
        "title": "How to deploy a locally built Jekyll site on GitHub",
        "excerpt":"You may ask why I should build the blog locally when GitHub does it for me. Well there are several reasons, for instance if you use some unsupported plugins, but here I will discuss only one practical reason that it made me spent some time to fix it.   I work usually on two PCs one in the office and one at home.  I have all my code in several git repositories hosted on GitLab and  GitHub.  Thus, when I implement some feature, let say in the office,  I push the code to the host and then at  home I pull the new code and vice versa. In this way, I have always my code up-to-date in both stations.   When the idea of starting this blog come out, I found that it was not possible to do such a thing with the  GitHub Pages.  Of course, GitHub Pages is a cheap and easy way to host a blog using  Jekyll but unfortunately  it breaks my development cycle work -&gt; commit -&gt; push -&gt; pull -&gt; work. As a matter of facts, if you use Jekyll hosted in GitHub Pages the blog is built every time you push the code on the branch master. There you can see the problem. If you are working on a post in the office, then you want to review it at home before publishing this is not possible. When you push it (to have the draft at home)  GitHub build and publish your post (:angry:).   As mentioned, GitHub host a blog/webpage/whatever so one does not need to let GitHub build it. One can build a blog in whatever way you want and put in the master branch of the repository the html files for the generated site. The issue now is where to keep the files needed for the generation of the blog. A possible solution is to have a repository for the source code and a repository for the hosting of the blog. However, I did not like the idea of having two repositories for just one project. So, I thought to use a branch for the development into the main repository:  - dev #contains the source code to generate the blog - master #contains the html pages   The only issue is how to avoid the manually coping of the file generated while you are in the dev branch and then commit those files in the master. Thus, I wrote a rakefile to handle all of this  SITE_DIR = \"_site\"   desc \"Build Jekyll site, copy files to master and commit/push to github\"  task :build, :message do |t, args|   raise \"Missing \\\"message\\\" argument for commit. Build with `rake build[\\\"message\\\"]`\".red unless args.message    build_jekyll    # checkout master, copy files and commit   system \"git checkout master\" or fail \"## [FAILED] master checkout\".red   puts \"## [SUCCESS] Master checked out\".green    system \"cp -r #{SITE_DIR}/* .\"   system \"rm -r #{SITE_DIR}\"   system \"git add -A\" # commit all changes    system \"git commit -m \\\"#{args.message}\\\"\" or fail \"## [FAILED] commit to master \".red   puts \"## [SUCCESS] webpage committed\".green    system \"git push\" or fail \"## [FAILED] can't push\".red   puts \"## [SUCCESS] push done. Webpage is alive\".green end   def build_jekyll   puts \"## Building jekyll\"   system \"jekyll build\" or fail \"## [FAILED] Jekyll build\".red   puts \"## [SUCCESS] Jekyll Build\".green end   The file is pretty straightforward.  From the dev branch, when you execute it, it builds the webpage, checkouts the master branch, and copies the _site directory in the repository main directory.  At the end all changes are committed and push, then GitHub makes it live. Therefore, this is a solution to my development cycle since I can work in the dev branch and there I can commit and push all the things I want (they not become live in the blog :+1:), in this way I can synchronize the repositories into my two stations. When I am happy with a post and I want to publish it, I just lunch the rake task:  rake build[\"commit message\"]  and my post is published automatically.   This post ends here, if you have comments/feedbacks drop me an email, they are really appreciated.   Ciao!     PS the color in the output strings it is made changing the the String attributes:  class String   def colorize(color_code)     \"\\e[#{color_code}m#{self}\\e[0m\"   end    def red     colorize(31)   end    def green     colorize(32)   end    def yellow     colorize(33)   end    def blue     colorize(34)   end    def pink     colorize(35)   end    def light_blue     colorize(36)   end end   ","categories": ["coding"],
        "tags": ["github","jekyll","rakefile"],
        "url": "https://imoronpirate.github.io/coding/deploy-static-site-on-github/",
        "teaser":null},{
        "title": "Everything you ever wanted to know about ~~sex~~ rotations",
        "excerpt":"  Almost certainty, at some point, one has to deal with rotations. Promptly, one encounters different Euler’s angles representations, Quaternions, axis-angles representations, and so forth.   In this post, I would present which parametrization I use that I found very useful in several situations I faced.   Rodrigues’ formula   To construct the rotation matrix, given the rotation axis and the angle, the Rodrigues’ formula is excellent.   The rotation matrix around and axis  (where ) of an angle  is     where  is the cross-product matrix given by     Rotation matrix from one vector to another one   Usually we have two vectors, for instance describing two planes, and we would like to rotate one vector, , to the other one, . This is a perfect application for the Rodrigues’ formula.   To rotate the vector  in order to coincide with the vector , we need to rotate  of an angle  around the axis . Therefore, we can use the Rodrigues’ formula for  and .   Get Euler’s angles from the rotation matrix   Suppose that you used the Rodrigues’ formula and you have the rotation matrix:     Then, you discovery that the API you are using for rotations accepts only the Euler’s angle. Than, the reaction is f**k this! I quit!   After you calm down, you ask yourself: ok how can I determined the angles from the rotation matrix? And then you realize: which angles? There are different representation of Euler’s angles! I am really done with this s**t! I am out!   Breath! Stay calm! Breath!   The API is a  representation, thanks to Wikipedia you have the rotation matrix as function of the angles. The rotation  consists of a rotation of  around -axis, then a rotation around -axis of an angle , and finally a rotation around the -axis of an angle . Therefore, the rotation matrix  is     First all, before calculating the angles, we should remind ourselves there are infinite solutions (the same rotation can be achieved with different sets of angles). Therefore, we restrict ourselves to the following range for the three angles     Angles calculation   We can easily see that , therefore,     Note that the solution is unique in the range we have chosen. In addition, we can find  from . Numerically, it  is extracted through  which returns a value in the range  as we need it. However, one must be careful since the sign is important here. Indeed, if  then  but if the cosine is negative,  then . We can write this compactly as     if  (the case  is discussed below). For the angle , we note that . Therefore,     where again we divided for  for taking the correct sign. Thus, we have a set of angles from our rotation matrix if .   If    If  is zero we cannot use the formulas above. Thus, we need to analyze two cases .    case   It is easy to see that     The rotation matrix become     Any  and  that satisfy the following equation will be a valid solution:     where only the difference is constrained. Thus, we can assign any value to one of the two angles, for instance  and take the value of .    case   This case is similar to the previous one     Therefore, the solution is     In both cases  we have that  and  are linked. This phenomenon is called Gimbal lock.   Pseudo-code   To summarize, we can extract the angles with the following pseudo-code   if (abs(R31) != 1) { // cos(theta) != 0     theta = -asin(R31);     psi = atan2(R32/cos(theta), R33/cos(theta));     phi = atan2(R21/cos(theta), R11/cos(theta)); } else {     phi = 0; // this is arbitrary, could be anything     if (R31 = -1) {         theta = pi/2;         psi = phi + atan2(R12, R13);     } else {         theta = -pi/2;         psi = -phi + atan2(-R12, R13);     } }     This post ends here, if you have comments/feedbacks drop me an email, they are appreciated.   Ahoy!  ","categories": ["math","coding"],
        "tags": ["Euler's angles","Rotations"],
        "url": "https://imoronpirate.github.io/math/coding/rotations/",
        "teaser":null}]
